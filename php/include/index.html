<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="Web-разработка, PHP: учебные материалы. Функция include.">
  <title>PHP: функция include</title>
  <link rel="stylesheet" href="../../compact.css">
  <link rel="stylesheet" href="../../github.css">
  <script src="../highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <link rel="shortcut icon" href="https://www.php.net/favicon.ico" type="image/x-icon">
</head>
<body>
  <nav class="menu">
    <ul>
      <li><a href="../../">Главная страница</a></li>
      <li><a href="../">PHP</a></li>
      <li><a href="#forms">Формы</a></li>
    </ul>
  </nav>

<h1>Функция include</h1>
<p>include предназначена для включения файлов в код сценария PHP во время исполнения сценария PHP.
</p>
<p>
В отличие от конструкции require конструкция include позволяет включать файлы в код PHP скрипта во время выполнения сценария. Синтаксис конструкции include выглядит следующим образом:
</p>
<pre><code>include имя_файла;</code></pre>
<p>Поясним принципиальную разницу между конструкциями require и include на конкретном практическом примере. Создадим 10 файлов с именами 1.txt, 2.txt и так далее до 10.txt, содержимое этих файлов – просто десятичные цифры 1, 2, … 10 (по одной цифре в каждом файле). Создадим такой сценарий PHP:</p>
<pre><code>&lt;?php
// Создаем цикл, в теле которого конструкция include
for($i=1; $i&lt;=10; $i++) {
include "$i.txt";
}
// Включили десять файлов: 1.txt, 2.txt, 3.txt ... 10.txt
// Результат - вывод 12345678910
?></code></pre>
<p>В результате мы получим вывод, состоящий из 10 цифр: "12345678910". Из этого мы можем сделать вывод, что каждый из файлов был включен по одному разу прямо во время выполнения цикла! Если мы поставим теперь вместо include require, то сценарий сгенерирует критическую ошибку (fatal error).</p>

<h3>Более строго:</h3>
<p>Файлы включаются исходя из пути указанного файла, или, если путь не указан, используется путь, указанный в директиве include_path. Если файл не найден в include_path, include попытается проверить директорию, в которой находится текущий включающий скрипт и текущую рабочую директорию перед тем, как выдать ошибку. Конструкция include выдаст E_WARNING, если не сможет найти файл; поведение отлично от require, который выдаст E_ERROR.</p>

<p>PHP преобразует сценарий во внутреннее представление, анализируя строки сценария по очереди, пока не доходит до конструкции include. Дойдя до include, PHP прекращает транслировать сценарий и переключается на указанный в include файл. Таким образом из-за подобного поведения транслятора, быстродействие сценария снижается, особенно при большом количестве включаемых с помощью include файлов. С require таких проблем нет, поскольку файлы с помощью <b>require</b> включаются до выполнения сценария, то есть на момент трансляции файл уже включен в сценарий.</p>
<p>Таким образом, целесообразнее использовать конструкцию <b>require</b> там, где не требуется динамическое включение файлов в сценарий, а конструкцию include использовать только с целью динамического включения файлов в код PHP скрипта.</p>
<p>Конструкция include поддерживает включения удаленных файлов. Например:</p>
<pre><code>&lt;?php
// Следующий пример на работает, поскольку пытается включить локальный файл
include 'file.php?foo=1&bar=2';
// Следующий пример работает
include 'http://www.example.com/file.php?foo=1&bar=2';
?></code></pre>
<p><b>Конструкция include позволяет включать удаленные файлы, если такая возможность включена в конфигурационном файле PHP.</b></p>
<p><b>Для того, чтобы удаленное включение файлов было доступно, необходимо в конфигурационном файле (php.ini) установить allow_url_fopen=1.</b></p>

<p>PHP позволяет работать с объектами URL, как с обычными файлами. Упаковщики, доступные по умолчанию, служат для работы с удаленными файлами с использованием протокола ftp или http.</p>
<p>Если "URL fopen-оболочки" включены в PHP (как в конфигурации по умолчанию), вы можете специфицировать файл, подключаемый с использованием URL (через HTTP), вместо локального пути. Если целевой сервер интерпретирует целевой файл как PHP-код, переменные могут передаваться в подключаемый файл с использованием URL-строки запроса, как в HTTP GET. Строго говоря, это не то же самое, что подключение файла и наследование им области видимости переменных родительского файла; ведь скрипт работает на удалённом сервере, а результат затем подключается в локальный скрипт.</p>
<pre><code>&lt;?php

/* Здесь предполагается, что www.example.com сконфигурирован для разбора .php
  * файлов, а не .txt файлов. Также 'Works' здесь означает, что переменные
  * $foo и $bar доступны в подключённом файле. */

// Не будет работать, так как file.txt не обрабатывается www.example.com как PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Не будет работать, поскольку ищет файл 'file.php?foo=1&bar=2' в локальной
// файловой системе.
include 'file.php?foo=1&bar=2';

// Следующий пример работает:
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Работает
include 'file.php';  // Работает
?></code></pre>

<h3>Область видимости переменных</h3>
<p>Когда файл включается, его код наследует ту же область видимости переменных, что и строка, на которой произошло включение. Все переменные, доступные на этой строке во включающем файле, будут также доступны во включаемом файле. Однако все функции и классы, объявленные во включаемом файле, имеют глобальную область видимости. Пример:</p>
<pre><code><b>vars.php</b>
&lt;?php

$color = 'зеленое';
$fruit = 'яблоко';

?>

<b>test.php</b>
&lt;?php

echo "Одно $color $fruit"; // Одно

include 'vars.php';

echo "Одно $color $fruit"; // Одно зеленое яблоко

?>
</code></pre>

<h2>Ссылки</h2>
<ul>
  <li><a href="https://www.php.net/manual/ru/function.include.php" target="_blank" rel="noopener noreferrer">Выражение include</a> включает и выполняет указанный файл</li>
</ul>
</body>
</html>
